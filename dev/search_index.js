var documenterSearchIndex = {"docs":
[{"location":"twosampletest/#Two-Sample-Hypothesis-Tests","page":"Two-Sample Tests","title":"Two Sample Hypothesis Tests","text":"","category":"section"},{"location":"twosampletest/#Introduction","page":"Two-Sample Tests","title":"Introduction","text":"","category":"section"},{"location":"twosampletest/","page":"Two-Sample Tests","title":"Two-Sample Tests","text":"The two-sample hypothesis testing strategies are based on Algorithm 1 by Gandy & Scott (2021)[gandyandscott2021].","category":"page"},{"location":"twosampletest/#twosample","page":"Two-Sample Tests","title":"TwoSampleTest","text":"","category":"section"},{"location":"twosampletest/","page":"Two-Sample Tests","title":"Two-Sample Tests","text":"The first basic strategy generates the treatment group","category":"page"},{"location":"twosampletest/","page":"Two-Sample Tests","title":"Two-Sample Tests","text":"beginaligned\n  theta y_texttrtm sim pleft(theta yright) \n  theta_texttrtm sim Kleft(theta cdotright)\nendaligned","category":"page"},{"location":"twosampletest/","page":"Two-Sample Tests","title":"Two-Sample Tests","text":"and the control group as","category":"page"},{"location":"twosampletest/","page":"Two-Sample Tests","title":"Two-Sample Tests","text":"beginaligned\n  theta_textctrl y_textctrl sim pleft(theta yright) \nendaligned","category":"page"},{"location":"twosampletest/","page":"Two-Sample Tests","title":"Two-Sample Tests","text":"where the test compares ","category":"page"},{"location":"twosampletest/","page":"Two-Sample Tests","title":"Two-Sample Tests","text":"(theta_texttrtm  y_texttrtm)\nquadtextversusquad \n(theta_textctrl  y_textctrl)","category":"page"},{"location":"twosampletest/","page":"Two-Sample Tests","title":"Two-Sample Tests","text":"TwoSampleTest","category":"page"},{"location":"twosampletest/#MCMCTesting.TwoSampleTest","page":"Two-Sample Tests","title":"MCMCTesting.TwoSampleTest","text":"TwoSampleTest(n_samples, n_mcmc_steps; n_control, n_treatment, n_mcmc_thin)\n\nTwo-sample hypothesis testing strategy. Algorithm 1 in Gandy & Scott (2021).\n\nArguments\n\nn_samples::Int: Number of samples from the joint p(θ, y) used for the computing the p-values.\nn_mcmc_steps::Int: Number of times the MCMC kernel is applied to initial sample from the joint. (Increasing this value improves the power of the test.)\n\nKeyword Arguments\n\nn_control::Int: Number of pure samples from the joint (control group). (Default: n_samples)\nn_treatment::Int: Number of samples from the MCMC kernel (treatment group). (Default: n_samples)\nn_mcmc_thin::Int: Number of thinning applied to the MCMC chain. The effect of this argument is the same as n_mcmc_steps.\n\nReturns\n\npvalues: P-value computed for each dimension of the statistic returned from statistics.\n\nRequirements\n\nThis test requires the following functions for model and kernel to be implemented:\n\nmarkovchain_transition\nsample_joint\n\nKeyword Arguments for Tests\n\nWhen calling mcmctest or seqmcmctest, this tests has an additional keyword argument:\n\ntwo_sample_test_pvalue: The p-value calculation strategy.\n\nThe default strategy is an approximate two-sample Kolmogorov-Smirnov test. Any function returning a single p-value from a two-sample hypothesis test will work. The format is as follows:\n\ntwo_sample_test_pvalue(x::AbstractVector, y::AbstractVector)::Real\n\n\n\n\n\n","category":"type"},{"location":"twosampletest/#twosamplegibbs","page":"Two-Sample Tests","title":"TwoSampleGibbsTest","text":"","category":"section"},{"location":"twosampletest/","page":"Two-Sample Tests","title":"Two-Sample Tests","text":"The second strategy performs applies an additional Gibbs sampling step when generating the treatment group  as","category":"page"},{"location":"twosampletest/","page":"Two-Sample Tests","title":"Two-Sample Tests","text":"beginaligned\n  theta y sim pleft(theta yright) \n  theta_texttrtm sim Kleft(theta cdotright) \n  y_texttrtm sim pleft(y mid theta_texttrtmright)\nendaligned","category":"page"},{"location":"twosampletest/","page":"Two-Sample Tests","title":"Two-Sample Tests","text":"resulting in the treatment group ","category":"page"},{"location":"twosampletest/","page":"Two-Sample Tests","title":"Two-Sample Tests","text":"(theta_texttrtm  y_texttrtm)","category":"page"},{"location":"twosampletest/","page":"Two-Sample Tests","title":"Two-Sample Tests","text":"The control group is generated the same as TwoSampleTest.","category":"page"},{"location":"twosampletest/","page":"Two-Sample Tests","title":"Two-Sample Tests","text":"To use this test, the user needs to implement the following interface for simulating from the conditional likelihood.","category":"page"},{"location":"twosampletest/","page":"Two-Sample Tests","title":"Two-Sample Tests","text":"sample_predictive","category":"page"},{"location":"twosampletest/#MCMCTesting.sample_predictive","page":"Two-Sample Tests","title":"MCMCTesting.sample_predictive","text":"sample_predictive(rng, model, θ)\n\nSample from the predictive distribution of model conditionally on θ\n\nArguments\n\nrng::Random.AbstractRNG: Random number generator.\nmodel: Model subject to test.\nθ: Model parameters to condition on.\n\nReturns\n\ny: Data generated from conditionally on θ from p(y|θ)\n\n\n\n\n\n","category":"function"},{"location":"twosampletest/","page":"Two-Sample Tests","title":"Two-Sample Tests","text":"TwoSampleGibbsTest","category":"page"},{"location":"twosampletest/#MCMCTesting.TwoSampleGibbsTest","page":"Two-Sample Tests","title":"MCMCTesting.TwoSampleGibbsTest","text":"TwoSampleTest(n_samples, n_mcmc_steps; n_control, n_treatment, n_mcmc_thin)\n\nTwo-sample hypothesis testing strategy with an additional Gibbs sampling step. Modified version of Algorithm 1 in Gandy & Scott 2021 for increased power.\n\nArguments\n\nn_samples::Int: Number of samples from the joint p(θ, y) used for the computing the p-values.\nn_mcmc_steps::Int: Number of times the MCMC kernel is applied to initial sample from the joint. (Increasing this value improves the power of the test.)\n\nKeyword Arguments\n\nn_control::Int: Number of pure samples from the joint (control group). (Default: n_samples)\nn_treatment::Int: Number of samples from the MCMC kernel (treatment group). (Default: n_samples)\nn_mcmc_thin::Int: Number of thinning applied to the MCMC chain. The effect of this argument is the same as n_mcmc_steps.\n\nReturns\n\npvalues: P-value computed for each dimension of the statistic returned from statistics.\n\nRequirements\n\nThis test requires the following functions for model and kernel to be implemented:\n\nmarkovchain_transition\nsample_joint\nsample_predictive\n\nKeyword Arguments for Tests\n\nWhen calling mcmctest or seqmcmctest, this tests has an additional keyword argument:\n\ntwo_sample_test_pvalue: The p-value calculation strategy.\n\nThe default strategy is an approximate two-sample Kolmogorov-Smirnov test. Any function returning a p-value to two sample groups will work. The format is as follows:\n\ntwo_sample_test_pvalue(x::AbstractVector, y::AbstractVector)::Real\n\nReferences\n\n\n\n\n\n","category":"type"},{"location":"twosampletest/#References","page":"Two-Sample Tests","title":"References","text":"","category":"section"},{"location":"twosampletest/","page":"Two-Sample Tests","title":"Two-Sample Tests","text":"[gandyandscott2021]: Gandy, A., & Scott, J. (2020). Unit testing for MCMC and other Monte Carlo methods. arXiv preprint arXiv:2001.06465.","category":"page"},{"location":"general/#General-Usage","page":"General Usage","title":"General Usage","text":"","category":"section"},{"location":"general/#Introduction","page":"General Usage","title":"Introduction","text":"","category":"section"},{"location":"general/","page":"General Usage","title":"General Usage","text":"The tests provided by MCMCTesting are frequentist hypothesis tests for testing the correctness of MCMC kernels. In particular, it compute the p-value for the null hypothesis that the MCMC kernel has the correct stationary distribution against the alternative hypothesis that it doesn't.","category":"page"},{"location":"general/","page":"General Usage","title":"General Usage","text":"Currently, MCMCTesting provide three different tests originally proposed by Gandy and Scott[gandyandscott2021]: ","category":"page"},{"location":"general/","page":"General Usage","title":"General Usage","text":"Simple Two-Sample Test\nTwo-Sample Test with an Additional Gibbs Step\nExact Rank Test","category":"page"},{"location":"general/","page":"General Usage","title":"General Usage","text":"The two-sample tests are generally applicable.  On the other hand, the exact rank test assumes that the MCMC kernel is reversible. Therefore, it can specifically be used to test reversibility.","category":"page"},{"location":"general/#Interface","page":"General Usage","title":"Interface","text":"","category":"section"},{"location":"general/","page":"General Usage","title":"General Usage","text":"The user needs to implement the following function specializations for the model and kernel subject to the test.","category":"page"},{"location":"general/","page":"General Usage","title":"General Usage","text":"sample_joint\nmarkovchain_transition","category":"page"},{"location":"general/#MCMCTesting.sample_joint","page":"General Usage","title":"MCMCTesting.sample_joint","text":"sample_joint(rng, model)\n\nSample from the joint distribution of the prior and the predictive distribution of model.\n\nArguments\n\nrng::Random.AbstractRNG: Random number generator.\nmodel: Model subject to test.\n\nReturns\n\nθ: Model parameter sampled from the prior p(θ).\ny: Data generated from conditionally on θ from p(y|θ)\n\n\n\n\n\n","category":"function"},{"location":"general/#MCMCTesting.markovchain_transition","page":"General Usage","title":"MCMCTesting.markovchain_transition","text":"markovchain_transition(rng, model, kernel, θ, y)\n\nPerform a single Markov chain transition of kernel on the previous state θ targeting the posterior of model conditioned on y.\n\nArguments\n\nrng::Random.AbstractRNG: Random number generator.\nmodel: Model forming the posterior p(θ|y) conditioned on y.\nθ: Previous state of the Markov chain.\ny: Data to condition on.\n\nReturns\n\nθ′: Next state of the Markov chain.\n\n\n\n\n\n","category":"function"},{"location":"general/","page":"General Usage","title":"General Usage","text":"Some tests might be require additional interfaces to be implemented. For an overview of how to implement these interfaces, refer to the tutorial.","category":"page"},{"location":"general/","page":"General Usage","title":"General Usage","text":"The model and kernel are then passed to MCMCTesting through the following struct:","category":"page"},{"location":"general/","page":"General Usage","title":"General Usage","text":"TestSubject","category":"page"},{"location":"general/#MCMCTesting.TestSubject","page":"General Usage","title":"MCMCTesting.TestSubject","text":"TestSubject(model, kernel)\n\nModel and MCMC kernel obejct subject to test.\n\nArguments\n\nmodel: Model subject to test.\nkernel: MCMC kernel subject to test.\n\n\n\n\n\n","category":"type"},{"location":"general/#Simulating-a-P-Value-with-mcmctest","page":"General Usage","title":"Simulating a P-Value with mcmctest","text":"","category":"section"},{"location":"general/","page":"General Usage","title":"General Usage","text":"Each of the test internally run simulations and compute a single p-value through the following routine:","category":"page"},{"location":"general/","page":"General Usage","title":"General Usage","text":"mcmctest","category":"page"},{"location":"general/#MCMCTesting.mcmctest","page":"General Usage","title":"MCMCTesting.mcmctest","text":"mcmctest([rng,] test, subject; kwargs...)\n\nSample a p-value according to test for subject\n\nArguments\n\nrng::Random.AbstractRNG: Random number generator. (Default: Random.default_rng().)\ntest::AbstractMCMCTest: Test strategy.\nsubject::TestSubject: MCMC algorithm and model subject to test.\n\nKeyword Arguments\n\nshow_progress::Bool: Whether to show the progress bar. (Default: true.)\nstatistics: Function for computing test statistics from samples generated from the tests. (See section below for additional description.)\nCheck the documentation for the respective test strategy for additional keyword arugments.\n\nCustom Test Statistics\n\nThe statistics used for the hypothesis tests can be modified by passing a custom funciton to statistics. The default statistics are the first and second moments computed as below.\n\nstatistics = params -> vcat(params, params.^2)\n\nThe cross-interaction can also be tested by adding an additional entry as below.\n\nstatistics = params -> vcat(params, params.^2, reshape(params*params',:))\n\nBut naturally, adding more statistics increase the computational cost of computing the tests.\n\nAlso, different tests may result in different statistics being computed through the same statistics function. For example, the two-sample test strategies generate both model parameters θ and data y. Therefore, params = vcat(θ, y). On the other hand, the exac rank test only generates model parameters θ. Therefore, params = θ. Naturally, statistics can also be used to select a subset of parameters used for testing. For example, for the two-sample test strategies, if we only want to use θ for the tests, where d = length(θ) > 0, one can do the following:\n\nstatistics = params -> θ[1:d]\n\n\n\n\n\n","category":"function"},{"location":"general/#Increasing-Power-with-seqmcmctest","page":"General Usage","title":"Increasing Power with seqmcmctest","text":"","category":"section"},{"location":"general/","page":"General Usage","title":"General Usage","text":"seqmcmctest (Algorithm 3[gandyandscott2021]) sequentially calls mcmctest to increase the power and ensure a low false rejection rate. Furthermore, the p-values from each component of the statistics are combined through multiple hypothesis adjustment.","category":"page"},{"location":"general/","page":"General Usage","title":"General Usage","text":"seqmcmctest","category":"page"},{"location":"general/#MCMCTesting.seqmcmctest","page":"General Usage","title":"MCMCTesting.seqmcmctest","text":"seqmcmctest([rng,] test, subject, false_rejection_rate, samplesize; kwargs...)\n\nSequential run multiple hypothesis tests to guarantee false_rejection_rate.\n\nArguments\n\nrng::Random.AbstractRNG: Random number generator.\ntest::AbstractMCMCTest: Test strategy.\nsubject::TestSubject: MCMC algorithm and model subject to test.\nfalse_rejection_rate::Real: Desired false rejection rate.\nsamplesize::Int: The number of p-values used at each test iteration.\n\nKeyword Arguments\n\nsamplesize_increase: Factor of increase for the samplsize after the first test iteration turns out inconclusive. (Default: 2.0)\nshow_progress::Bool: Whether to show progress. (Default: true)\npvalue_adjustmeht::MultipleTesting.PValueAdjustment: P-value adjustment for multiple testing over the elements of the statistic. (Default: MultipleTesting.Bonferroni())\n\nAdditional keyword arguments are passed to internal calls to mcmctest.\n\nReturns\n\ntest_result::Bool: true if the null-hypothesis (the MCMC algorithm has the correct stationary distribution) wasn't rejected, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"general/#References","page":"General Usage","title":"References","text":"","category":"section"},{"location":"general/","page":"General Usage","title":"General Usage","text":"[gandyandscott2021]: Gandy, A., & Scott, J. (2020). Unit testing for MCMC and other Monte Carlo methods. arXiv preprint arXiv:2001.06465.","category":"page"},{"location":"ranksim/#ranksim","page":"Visualizing Ranks","title":"Visualizing Ranks","text":"","category":"section"},{"location":"ranksim/#Introduction","page":"Visualizing Ranks","title":"Introduction","text":"","category":"section"},{"location":"ranksim/","page":"Visualizing Ranks","title":"Visualizing Ranks","text":"This section documents how to visualize ranks sampled using Algorithm 2 by Gandy & Scott (2021)[GS2021]. For more information, refer to the documentation for the exact rank test.","category":"page"},{"location":"ranksim/#Simulating-Ranks","page":"Visualizing Ranks","title":"Simulating Ranks","text":"","category":"section"},{"location":"ranksim/","page":"Visualizing Ranks","title":"Visualizing Ranks","text":"simulate_ranks","category":"page"},{"location":"ranksim/#MCMCTesting.simulate_ranks","page":"Visualizing Ranks","title":"MCMCTesting.simulate_ranks","text":"simulate_ranks([rng,] test, subject; kwargs...)\n\nSimulate ranks according to the exact rank test strategy.\n\nArguments\n\nrng::Random.AbstractRNG: Random number generator. (Default: Random.default_rng().)\ntest::AbstractMCMCTest: Test strategy.\nsubject::TestSubject: MCMC algorithm and model subject to test.\n\nKeyword Arguments\n\ntie_epsilon::Real: The tolerance for declaring a difference in statistic as a tie. (Default: eps(Float32).)\nstatistics: Function for computing test statistics from samples generated from the tests. (See section below for additional description.)\nshow_progress::Bool: Whether to show progress.\n\nReturns\n\nranks::Matrix: The simualted ranks. Each row are the rank samples of each statistic.\n\n\n\n\n\n","category":"function"},{"location":"ranksim/#Visualizing-Ranks-with-Plots","page":"Visualizing Ranks","title":"Visualizing Ranks with Plots","text":"","category":"section"},{"location":"ranksim/","page":"Visualizing Ranks","title":"Visualizing Ranks","text":"We provide a Plots recipe for visualizing the ranks:","category":"page"},{"location":"ranksim/","page":"Visualizing Ranks","title":"Visualizing Ranks","text":"rankplot","category":"page"},{"location":"ranksim/#MCMCTesting.rankplot","page":"Visualizing Ranks","title":"MCMCTesting.rankplot","text":"rankplot(test, ranks; kwargs...)\n\nPlot the simulated ranks using simulate_ranks.\n\ninfo: Info\nPlots must be imported to use this plot recipe.\n\nArguments\n\ntest::ExactRankTest: The exact rank test object used to simulate the ranks.\nranks: The output of simulate_rank.\n\nKeyword Arguments\n\nstats_names: The name for the statistics used in the rank simulation. The default argument automatically assign default names. (Default: :auto). \nKeyword arguments corresponding Plots attributes, such as bins, layout, size, may apply.\n\n\n\n\n\n","category":"function"},{"location":"ranksim/","page":"Visualizing Ranks","title":"Visualizing Ranks","text":"This can be used as follows:","category":"page"},{"location":"ranksim/","page":"Visualizing Ranks","title":"Visualizing Ranks","text":"using Plots\nusing MCMCTesting\n\n# Set the simulation here\n\nranks = simulate_ranks(test, subject)\nrankplot(test, ranks; param_names)","category":"page"},{"location":"ranksim/","page":"Visualizing Ranks","title":"Visualizing Ranks","text":"Also refer to the tutorial for a working example.","category":"page"},{"location":"ranksim/#References","page":"Visualizing Ranks","title":"References","text":"","category":"section"},{"location":"ranksim/","page":"Visualizing Ranks","title":"Visualizing Ranks","text":"[GS2021]: Gandy, A., & Scott, J. (2020). Unit testing for MCMC and other Monte Carlo methods. arXiv preprint arXiv:2001.06465.","category":"page"},{"location":"exactranktest/#exactrank","page":"Exact Rank Tests","title":"Exact Rank Hypothesis Tests","text":"","category":"section"},{"location":"exactranktest/#Introduction","page":"Exact Rank Tests","title":"Introduction","text":"","category":"section"},{"location":"exactranktest/","page":"Exact Rank Tests","title":"Exact Rank Tests","text":"The exact rank hypothesis testing strategy is based on Algorithm 2 by Gandy & Scott (2021)[GS2021].","category":"page"},{"location":"exactranktest/#ExactRankTest","page":"Exact Rank Tests","title":"ExactRankTest","text":"","category":"section"},{"location":"exactranktest/","page":"Exact Rank Tests","title":"Exact Rank Tests","text":"The ranks are computed by simulating a single Markov chain backwards and forward. First, a random midpoint is simulated as","category":"page"},{"location":"exactranktest/","page":"Exact Rank Tests","title":"Exact Rank Tests","text":"beginaligned\n   M sim mathrmUniform(1L)\nendaligned","category":"page"},{"location":"exactranktest/","page":"Exact Rank Tests","title":"Exact Rank Tests","text":"where L = textttn_mcmc_steps. Then, we simulate the Markov chain forward and backward as","category":"page"},{"location":"exactranktest/","page":"Exact Rank Tests","title":"Exact Rank Tests","text":"beginalignat*3\n  theta_M-l sim Kleft(theta_L-l+1 cdot right) qquad textfor l = 1 ldots M-1 \n  theta_l   sim Kleft(theta_l-1 cdot right) qquad textfor l = M+1 ldots L\nendalignat*","category":"page"},{"location":"exactranktest/","page":"Exact Rank Tests","title":"Exact Rank Tests","text":"forming the chain","category":"page"},{"location":"exactranktest/","page":"Exact Rank Tests","title":"Exact Rank Tests","text":"theta_1 ldots  theta_M ldots  theta_L","category":"page"},{"location":"exactranktest/","page":"Exact Rank Tests","title":"Exact Rank Tests","text":"The rank is the ranking of the statistics of theta_M. If the sampler and the model are correct, the rank has an uniform distribution as long as the midpoint is independently sampled.","category":"page"},{"location":"exactranktest/","page":"Exact Rank Tests","title":"Exact Rank Tests","text":"ExactRankTest","category":"page"},{"location":"exactranktest/#MCMCTesting.ExactRankTest","page":"Exact Rank Tests","title":"MCMCTesting.ExactRankTest","text":"ExactRankTest(n_samples, n_mcmc_steps; n_mcmc_thin)\n\nExact rank hypothesis testing strategy for reversible MCMC kernels. Algorithm 2 in Gandy & Scott (2021).\n\nArguments\n\nn_samples::Int: Number of ranks to be simulated.\nn_mcmc_steps::Int: Number of MCMC states to be simulated for simulating a single rank.\nn_mcmc_thin::Int: Number of thinning applied to the MCMC chain.\n\nReturns\n\npvalues: P-value computed for each dimension of the statistic returned from statistics.\n\nRequirements\n\nThis test requires the following functions for model and kernel to be implemented:\n\nmarkovchain_transition\nsample_joint\n\nFurthermore, this test explicitly assumes the following\n\nkernel is reversible.\n\nApplying this tests to an irreversible kernel will result in false negatives even if its stationary distribution is correct.\n\nKeyword Arguments for Tests\n\nWhen calling mcmctest or seqmcmctest, this tests has an additional keyword argument:\n\nuniformity_test_pvalue: The p-value calculation strategy.\n\nThe default strategy is an chi^2 test. Any function returning a single p-value from a uniformity hypothesis test will work. The format is as follows:\n\nuniformity_test_pvalue(x::AbstractVector)::Real\n\n\n\n\n\n","category":"type"},{"location":"exactranktest/#References","page":"Exact Rank Tests","title":"References","text":"","category":"section"},{"location":"exactranktest/","page":"Exact Rank Tests","title":"Exact Rank Tests","text":"[GS2021]: Gandy, A., & Scott, J. (2020). Unit testing for MCMC and other Monte Carlo methods. arXiv preprint arXiv:2001.06465.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MCMCTesting","category":"page"},{"location":"#MCMCTesting","page":"Home","title":"MCMCTesting","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MCMCTesting.","category":"page"},{"location":"","page":"Home","title":"Home","text":"MCMCTesting provides the MCMC testing algorithms developed by Gandy & Scott (2021)[GS2021]. These tests can be seen as an improvement of the hypothesis testing approach proposed by Geweke [G2004]. Unlike simulation-based calibration (SBC; [TBSVG2018][YD2023][MMKBPBHFGV2022]), these tests are more appropriate for testing the exactness of the MCMC algorithm rather than the identifiability of the models. This is because the tests focus on maximizing the power for verify the validity of individual Markov transitions instead of a set of samples. Furthermore, unlike SBC, the approach of Gandy & Scott[GS2021] is able to exactly satisfy the assumptions required for the theoretical guarantees.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[GS2021]: Gandy, A., & Scott, J. (2020). Unit testing for MCMC and other Monte Carlo methods. arXiv preprint arXiv:2001.06465.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[G2004]: Geweke, J. (2004). Getting it right: Joint distribution tests of posterior simulators. Journal of the American Statistical Association, 99(467), 799-804.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[TBSVG2018]: Talts, S., Betancourt, M., Simpson, D., Vehtari, A., & Gelman, A. (2018). Validating Bayesian inference algorithms with simulation-based calibration. arXiv preprint arXiv:1804.06788.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[YD2023]: Yao, Y., & Domke, J. (2023, November). Discriminative Calibration: Check Bayesian Computation from Simulations and Flexible Classifier. In Thirty-seventh Conference on Neural Information Processing Systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[MMKBPBHFGV2022]: Modrák, M., Moon, A. H., Kim, S., Bürkner, P., Huurre, N., Faltejsková, K., ... & Vehtari, A. (2022). Simulation-based calibration checking for Bayesian computation: The choice of test quantities shapes sensitivity. arXiv preprint arXiv:2211.02383.","category":"page"},{"location":"example/#tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"example/#Problem-Setup","page":"Tutorial","title":"Problem Setup","text":"","category":"section"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"Let's consider a simple Normal-Normal model:","category":"page"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"beginaligned\ntheta_1 sim mathrmnormalleft(0   sigma^2right) \ntheta_2 sim mathrmnormalleft(0   sigma^2right) \ny        sim mathrmnormalleft(theta_1 + theta_2 sigma_epsilon^2right)\nendaligned","category":"page"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"The joint log-likelihood can be implemented as follows:","category":"page"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"using Random\nusing Distributions\n\nstruct Model\n    sigma    ::Float64\n    sigma_eps::Float64\n    y        ::Float64\nend\nnothing","category":"page"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"For sampling from the posterior, a simple Gibbs sampling strategy is possible:","category":"page"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"struct Gibbs end\n\nfunction complete_conditional(θ::Real, σ²::Real, σ²_ϵ::Real, y::Real)\n    μ = σ²/(σ²_ϵ + σ²)*(y - θ)\n    σ = 1/sqrt(1/σ²_ϵ + 1/σ²)\n    Normal(μ, σ)\nend\n\nfunction step(rng::Random.AbstractRNG, model::Model, ::Gibbs, θ)\n    θ    = copy(θ)\n    y    = model.y\n    σ²   = model.sigma^2\n    σ²_ϵ = model.sigma_eps^2\n    θ[1] = rand(rng, complete_conditional(θ[2], σ², σ²_ϵ, y))\n    θ[2] = rand(rng, complete_conditional(θ[1], σ², σ²_ϵ, y))\n    θ\nend\nnothing","category":"page"},{"location":"example/#Testing-the-Gibbs-Sampler","page":"Tutorial","title":"Testing the Gibbs Sampler","text":"","category":"section"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"All of the functionalities of MCMCTesting assume that we can sample from the joint distribution p(theta y). This is done by as follows:","category":"page"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"using MCMCTesting\n\nfunction MCMCTesting.sample_joint(rng::Random.AbstractRNG, model::Model)\n    θ₁ = rand(rng, Normal(0, model.sigma))\n    θ₂ = rand(rng, Normal(0, model.sigma))\n    θ  = [θ₁, θ₂]\n    y  = rand(rng, Normal(θ[1] + θ[2], model.sigma_eps))\n    θ, y\nend\nnothing","category":"page"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"The Gibbs samplers can be connected to MCMCTesting by implementing the following:","category":"page"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"using Accessors\n\nfunction MCMCTesting.markovchain_transition(\n    rng::Random.AbstractRNG, model::Model, kernel, θ, y\n)\n    model′ = @set model.y = only(y)\n    step(rng, model′, kernel, θ)\nend\nnothing","category":"page"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"Let's check that the implementation is correct by ","category":"page"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"model = Model(1., .5, randn())\nkernel = Gibbs()\ntest = TwoSampleTest(100, 100)\nsubject = TestSubject(model, kernel)\nseqmcmctest(test, subject, 0.0001, 100; show_progress=false)","category":"page"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"true means that the tests have passed.","category":"page"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"Now, let's consider two erroneous implementations:","category":"page"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"struct GibbsWrongMean end\n\nfunction complete_conditional_wrongmean(θ::Real, σ²::Real, σ²_ϵ::Real, y::Real)\n    μ = σ²/(σ²_ϵ + σ²)*(y + θ)\n    σ = 1/sqrt(1/σ²_ϵ + 1/σ²)\n    Normal(μ, σ)\nend\n\nfunction step(rng::Random.AbstractRNG, model::Model, ::GibbsWrongMean, θ)\n    θ    = copy(θ)\n    y    = model.y\n    σ²   = model.sigma^2\n    σ²_ϵ = model.sigma_eps^2\n\n    θ[1] = rand(rng, complete_conditional_wrongmean(θ[2], σ², σ²_ϵ, y))\n    θ[2] = rand(rng, complete_conditional_wrongmean(θ[1], σ², σ²_ϵ, y))\n    θ\nend\n\nstruct GibbsWrongVar end\n\nfunction complete_conditional_wrongvar(θ::Real, σ²::Real, σ²_ϵ::Real, y::Real)\n    μ = σ²/(σ²_ϵ + σ²)*(y - θ)\n    Normal(μ, sqrt(σ²))\nend\n\nfunction step(rng::Random.AbstractRNG, model::Model, ::GibbsWrongVar, θ)\n    θ    = copy(θ)\n    y    = model.y\n    σ²   = model.sigma^2\n    σ²_ϵ = model.sigma_eps^2\n\n    if rand(Bernoulli(0.5))\n        θ[1] = rand(rng, complete_conditional_wrongvar(θ[2], σ², σ²_ϵ, y))\n        θ[2] = rand(rng, complete_conditional_wrongvar(θ[1], σ², σ²_ϵ, y))\n    else\n        θ[2] = rand(rng, complete_conditional_wrongvar(θ[1], σ², σ²_ϵ, y))\n        θ[1] = rand(rng, complete_conditional_wrongvar(θ[2], σ², σ²_ϵ, y))\n    end\n    θ\nend\nnothing","category":"page"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"The kernel with a wrong mean fails:","category":"page"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"kernel = GibbsWrongMean()\nsubject = TestSubject(model, kernel)\nseqmcmctest(test, subject, 0.0001, 100; show_progress=false)","category":"page"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"and so does the one with the wrong variance:","category":"page"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"kernel = GibbsWrongVar()\nsubject = TestSubject(model, kernel)\nseqmcmctest(test, subject, 0.0001, 100; show_progress=false)","category":"page"},{"location":"example/#Visualizing-Simulated-Ranks","page":"Tutorial","title":"Visualizing Simulated Ranks","text":"","category":"section"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"MCMCTesting also provides some basic plot recipes for visualizing the simulated rank for the exact rank test. For this, Plots must be imported before MCMCTesting.","category":"page"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"using Plots\ngr()\nusing MCMCTesting\nnothing","category":"page"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"Also, since the exact rank test explicitly requires the MCMC kernel to be reversible, we modify the previous Gibbs sampler to use a random scan order.","category":"page"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"function step(rng::Random.AbstractRNG, model::Model, ::Gibbs, θ)\n    θ    = copy(θ)\n    y    = model.y\n    σ²   = model.sigma^2\n    σ²_ϵ = model.sigma_eps^2\n    if rand(Bernoulli(0.5))\n        θ[1] = rand(rng, complete_conditional(θ[2], σ², σ²_ϵ, y))\n        θ[2] = rand(rng, complete_conditional(θ[1], σ², σ²_ϵ, y))\n    else\n        θ[2] = rand(rng, complete_conditional(θ[1], σ², σ²_ϵ, y))\n        θ[1] = rand(rng, complete_conditional(θ[2], σ², σ²_ϵ, y))\n    end\n    θ\nend\n\nfunction step(rng::Random.AbstractRNG, model::Model, ::GibbsWrongVar, θ)\n    θ    = copy(θ)\n    y    = model.y\n    σ²   = model.sigma^2\n    σ²_ϵ = model.sigma_eps^2\n    if rand(Bernoulli(0.5))\n        θ[1] = rand(rng, complete_conditional_wrongvar(θ[2], σ², σ²_ϵ, y))\n        θ[2] = rand(rng, complete_conditional_wrongvar(θ[1], σ², σ²_ϵ, y))\n    else\n        θ[2] = rand(rng, complete_conditional_wrongvar(θ[1], σ², σ²_ϵ, y))\n        θ[1] = rand(rng, complete_conditional_wrongvar(θ[2], σ², σ²_ϵ, y))\n    end\n    θ\nend\nnothing","category":"page"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"Then, we can simulate the ranks and then plot them using `Plots.","category":"page"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"test = ExactRankTest(1000, 30, 10)\n\nrank_correct = simulate_ranks(test, TestSubject(model, Gibbs()); show_progress=false)\nrank_wrong = simulate_ranks(test, TestSubject(model, GibbsWrongVar()); show_progress=false)\n\nparam_names = [\"θ1 mean\", \"θ2 mean\", \"θ1 var\", \"θ2 var\"]\nrankplot(test, rank_wrong; param_names)\nrankplot!(test, rank_correct; param_names)\nsavefig(\"rankplot.svg\")\nnothing","category":"page"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"example/","page":"Tutorial","title":"Tutorial","text":"We can see that the ranks of the erroneous kernel are not uniform.","category":"page"}]
}
